<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-11-28T09:32:44.245649"><title>RetroFit | Jetpack Compose</title><script type="application/json" id="virtual-toc-data">[{"id":"key-features-of-retrofit","level":0,"title":"Key Features of Retrofit:","anchor":"#key-features-of-retrofit"},{"id":"implementation","level":0,"title":"Implementation","anchor":"#implementation"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b518/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="RetroFit | Jetpack Compose"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Jetpack Compose Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/retrofit.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="RetroFit | Jetpack Compose"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/retrofit.html#webpage",
    "url": "writerside-documentation/retrofit.html",
    "name": "RetroFit | Jetpack Compose",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Jetpack Compose Help"
}</script><!-- End Schema.org --></head><body data-id="RetroFit" data-main-title="RetroFit" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Jetpack Compose  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="RetroFit" id="RetroFit.md">RetroFit</h1><p id="z3ujnhn_3">Retrofit is a type-safe HTTP client for Android and Java developed by Square, Inc. It simplifies the process of making network requests from your app to a web service. Retrofit turns your HTTP API into a Java (or Kotlin) interface, allowing you to define the endpoints and the HTTP methods (such as GET, POST, PUT, DELETE) to interact with the web service.</p><section class="chapter"><h2 id="key-features-of-retrofit" data-toc="key-features-of-retrofit">Key Features of Retrofit:</h2><ul class="list _bullet" id="z3ujnhn_6"><li class="list__item" id="z3ujnhn_8"><p id="z3ujnhn_13"><span class="control" id="z3ujnhn_14">Declarative API:</span> You define an interface with methods representing API endpoints and their parameters. Annotations (<code class="code" id="z3ujnhn_15">@GET</code>, <code class="code" id="z3ujnhn_16">@POST</code>, <code class="code" id="z3ujnhn_17">@PUT</code>, <code class="code" id="z3ujnhn_18">@DELETE</code>, etc.) specify the <code class="code" id="z3ujnhn_19">HTTP</code> method and relative URL for each endpoint.</p></li><li class="list__item" id="z3ujnhn_9"><p id="z3ujnhn_20"><span class="control" id="z3ujnhn_21">Type Safety:</span> Retrofit generates an implementation of the interface at runtime using Java (or Kotlin) reflection. This provides type-safe access to the APIs and ensures that the correct data types are used for request and response bodies.</p></li><li class="list__item" id="z3ujnhn_10"><p id="z3ujnhn_22"><span class="control" id="z3ujnhn_23">Easy Integration with JSON:</span> Retrofit automatically converts JSON responses to Java/Kotlin objects using a JSON converter (like Gson) included by default. You can also use other converters for XML or Protocol Buffers.</p></li><li class="list__item" id="z3ujnhn_11"><p id="z3ujnhn_24"><span class="control" id="z3ujnhn_25">Customization:</span> You can customize the HTTP request headers, query parameters, and body content using annotations and methods in your interface.</p></li><li class="list__item" id="z3ujnhn_12"><p id="z3ujnhn_26"><span class="control" id="z3ujnhn_27">Asynchronous and Synchronous Requests:</span> Retrofit supports both synchronous and asynchronous execution of network requests. Asynchronous requests are typically handled using coroutines (with Kotlin) or callbacks (with Java).</p></li></ul><div class="code-block" data-lang="kotlin">
 @GET(&quot;posts/{id}&quot;)
    suspend fun getPost(@Path(&quot;id&quot;) postId: Int): Post
    @POST(&quot;posts&quot;)
    suspend fun createPost(@Body post: Post): Response&lt;Post&gt;
    @PUT(&quot;posts/{id}&quot;)
    suspend fun updatePost(@Path(&quot;id&quot;) postId: Int, @Body post: Post): Response&lt;Post&gt;
    @DELETE(&quot;posts/{id}&quot;)
    suspend fun deletePost(@Path(&quot;id&quot;) postId: Int): Response&lt;Unit&gt;
</div></section><section class="chapter"><h2 id="implementation" data-toc="implementation">Implementation</h2><div class="tabs" id="z3ujnhn_28" data-anchors="[z3ujnhn_36,z3ujnhn_37]"><div class="tabs__content" data-gtm="tab" id="z3ujnhn_36" data-title="Groovy"><div class="code-block" data-lang="groovy" data-title="Groovy">
    //Optional  
    implementation 'com.squareup.retrofit2:retrofit:2.9.0'
    // Json Converter to Kotlin Objects
    implementation 'com.squareup.retrofit2:converter-gson:2.9.0'
    //If the API provides Images
    implementation 'io.coil-kt:coil-compose:1.4.0'
</div></div><div class="tabs__content" data-gtm="tab" id="z3ujnhn_37" data-title="Kotlin"><div class="code-block" data-lang="kotlin" data-title="Kotlin">
    //Optional  
    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)
    // Json Converter to Kotlin Objects
    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)
    //If the API provides Images
    implementation(&quot;io.coil-kt:coil:2.0.0&quot;)
</div></div></div><p id="z3ujnhn_29">Retrofit allows simplifies the data manipulation and allows to convert Jsons into Java or Kotlin objects. That is why is recommended to work with DataClasses to control the data structure received and posted.</p><div class="code-block" data-lang="kotlin">
    data class Entity(
    val id: String,
    val name: String,
    val image: String
)
</div><aside class="prompt" data-type="note" data-title="" id="z3ujnhn_31"><p id="z3ujnhn_40"><span class="control" id="z3ujnhn_42">Note</span></p><p id="z3ujnhn_41">The entity attributes must be named the same as the source.</p></aside><p id="z3ujnhn_32">Then is recommended to create an <code class="code" id="z3ujnhn_43">Interface</code> that contains all de abstract functions to work with the data (<code class="code" id="z3ujnhn_44">GET</code>, <code class="code" id="z3ujnhn_45">POST</code>, <code class="code" id="z3ujnhn_46">PUT</code>, <code class="code" id="z3ujnhn_47">DELETE</code>, etc.)</p><div class="code-block" data-lang="kotlin">
  interface ApiService {
    @GET(&quot;endPoint$API_KEY&quot;)
    suspend fun getAll(): Response&lt;List&lt;Entity&gt;&gt;
  // Get an specific Element
  @GET(&quot;endpoint/{id}$API_KEY&quot;)
    suspend fun getDetails(@Path(value = &quot;id&quot;)id : Int) : Response&lt;Entity&gt;
}

</div><section class="chapter"><h3 id="adding-parameters" data-toc="adding-parameters">Adding parameters</h3><p id="z3ujnhn_48">Sometimes, the API requests will require specific parameters to execute the query successfully or to get specific content or data.</p><p id="z3ujnhn_49">RetroFit allows to add parameters to the queries to get specific data or to condition the query before it executes.</p><p id="z3ujnhn_50">There is <span class="control" id="z3ujnhn_61">2</span> kind of parameters:</p><ul class="list _bullet" id="z3ujnhn_51"><li class="list__item" id="z3ujnhn_62"><section class="chapter"><h4 id="the-required" data-toc="the-required">The required:</h4></section></li></ul><p id="z3ujnhn_52">These parameters must be added whenever executing the query. This means the endpoint we are working with requires these parameters to fetch and send data.</p><p id="z3ujnhn_53">These parameters must be added using <code class="code" id="z3ujnhn_64">@Path</code></p><div class="code-block" data-lang="kotlin">
 @GET(&quot;endpoint/{id}$API_KEY&quot;)
    suspend fun getDetails(@Path(value = &quot;id&quot;)id : Int) : Response&lt;Entity&gt;
}
</div><ul class="list _bullet" id="z3ujnhn_55"><li class="list__item" id="z3ujnhn_65"><section class="chapter"><h4 id="the-optionals" data-toc="the-optionals">The optionals:</h4></section></li></ul><p id="z3ujnhn_56">Usually these parameters are not required and the API handles them adding a default value, however, these parameters allow to the developer to manage the queries and condition them.</p><p id="z3ujnhn_57">These parameters must be added using <code class="code" id="z3ujnhn_67">@Query</code></p><div class="code-block" data-lang="kotlin">
 @GET(&quot;endpoint$API_KEY&quot;)
    suspend fun getAll(@Path(value = &quot;param&quot;)param : Any) : Response&lt;Entity&gt;
}
</div><p id="z3ujnhn_59">If some of the optional parameters must be changed from its default value, then, it can be changed directly from the <code class="code" id="z3ujnhn_68">@GET()</code> tag.</p><div class="code-block" data-lang="kotlin">
 @GET(&quot;endpoint$API_KEY&amp;another_param=value&quot;) // The value could change according to the endpoint documentation. 
    suspend fun getAll(@Path(value = &quot;param&quot;)param : Any) : Response&lt;Entity&gt;
}
</div></section><section class="chapter"><h3 id="using-hilt" data-toc="using-hilt">Using Hilt</h3><p id="z3ujnhn_69">RetroFit supports Hilt and DI, so according to the <a href="dagger-hilt.html" id="z3ujnhn_76" data-tooltip="Hilt is a dependency injection library for Android that reduces the boilerplate of doing manual dependency injection in your project. Doing manual dependency injection requires you to construct every class and its dependencies by hand, and to use containers to reuse and manageâ€¦">Hilt Documentation</a> it is recommended to set up Hilt.</p><div class="code-block" data-lang="kotlin">
...
companion object{
const val BASE_URL = &quot;https://api.rawg.io/api/&quot;
        const val API_KEY = &quot;?key=e90bfcb82b4440f19ca2c1a2bca3ecf0&quot;
}
</div><div class="code-block" data-lang="kotlin">
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    @Provides
    @Singleton
    fun provideRetrofit(): Retrofit {
        return Retrofit.Builder()
            .baseUrl(BASE_URL) 
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
</div><aside class="prompt" data-type="note" data-title="" id="z3ujnhn_72"><p id="z3ujnhn_77"><span class="control" id="z3ujnhn_79">Note</span></p><p id="z3ujnhn_78">Android Recommends keeping the BASE_URL in external files such as .env or a Companion Objects as Constants</p></aside><section class="chapter"><h4 id="repositories" data-toc="repositories">Repositories</h4><p id="z3ujnhn_80">Create a repository to handle data operations.</p><div class="code-block" data-lang="kotlin">
class EntityRepository @Inject constructor(private val apiService: ApiService) {
// Returning the Response
suspend fun getAll(): Response&lt;List&lt;Entity&gt;&gt; = apiService.getAll()
}
// Getting the response and returning the Entity
suspend fun getAll(): List&lt;Entity&gt;? {
    val response = apiService.getAll()
    if (response.isSuccessful) return response.body()?.results
    return null
}
</div></section><section class="chapter"><h4 id="viewmodel-support" data-toc="viewmodel-support">ViewModel support</h4><p id="z3ujnhn_82">Create a ViewModel to fetch data from the repository and expose it to the UI.</p><div class="code-block" data-lang="kotlin">
@HiltViewModel
class EntityViewModel @Inject constructor(private val repository: EntityRepository) : ViewModel() {
    private val _data = MutableStateFlow&lt;List&lt;Entity&gt;&gt;(emptyList())
    val data: StateFlow&lt;List&lt;Entity&gt;&gt; = _data.asState()
  // If it is necessary that the function were executed whenever de ViewModel is Called  
  init {
    fetchData()
  }
  // Function that calls de repository functions
  private fun fetchData() {
    viewModelScope.launch(Dispatcher.IO) {
      val result = repository.getAll()
      _data.value = result
    }
  }
</div></section><section class="chapter"><h4 id="images" data-toc="images">Images</h4><p id="z3ujnhn_84">RetroFit also supports working with Images, but it is done via Coil dependency.</p><div class="code-block" data-lang="kotlin">
@Composable
fun CardImage(image : String){
    val dataImage = rememberImagePainter(data = image)
    Image(painter = dataImage, contentDescription = null, contentScale = ContentScale.Crop,
        modifier = Modifier.fillMaxWidth().height(250.dp))
}
</div><p id="z3ujnhn_86">This documentation covers the integration and usage of Retrofit for network requests (with <code class="code" id="z3ujnhn_87">Response&lt;&gt;</code>), Coil for image loading, Hilt for dependency injection, and ViewModel with Flow for managing UI-related data in an Android application. With these steps, you can fetch data from a network, inject dependencies easily, and display images efficiently. You can expand on this by adding more advanced features such as error handling, caching, and more.</p></section></section></section><div class="last-modified">Last modified: 28 noviembre 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="room-dao.html" class="navigation-links__prev">Room Dao</a><a href="intents.html" class="navigation-links__next">Intents</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b518/app.js"></script></body></html>